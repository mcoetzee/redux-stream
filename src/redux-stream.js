import { Observable, Subject } from './rx-ext';
import { Scheduler } from 'rxjs';
import { combineReducers } from 'redux';
import { moduleReducer, hydrateActionType, clearStateActionType } from './module-utils';

const CONNECT_STREAM = '@udeo/CONNECT_STREAM';

export function reduxStream(createReduxStore) {
  /**
   * @typedef moduleDefinition
   * @type {Object}
   * @property {Function} [effects] - Provides the module's side effects.
   * Returns an array of action streams to be reduced.
   * @property {Function} reducer - The reducer of the provided data flow.
   * Returns the next version of the module's state (a plain old reducer function).
   */

  /**
   * Creates a Redux Store which houses a collection of state streams. It adds a state
   * stream for each module definition provided.
   *
   * @param {Object} definitions - The module definitions. Each module definition
   * provides two functions used to form the module's state stream.
   *
   * @param {Object} [preloadedState] - The initial state. Can be used to hydrate
   * the store from state generated by the server in universal apps.
   *
   * @returns {Object} store - A Redux Stream store that allows you to subscribe to the state streams,
   * dispatch actions and read the current state of the application.
   */
  return function createStore(definitions, preloadedState) {
    // The stream where actions are dispatched into
    const dispatch$ = new Subject();
    // The stream where all modules' effects flow through
    const sideEffect$ = new Subject();
    const stateStreams = {};
    let reduxStore;
    let state$;

    /**
     * Initialize the store with provided module definitions
     */
    function init(defs) {
      const moduleNames = Object.keys(defs);
      const reducers = {};
      let reducer;
      moduleNames.forEach(moduleName => {
        const moduleResources = defs[moduleName];
        reducer = typeof moduleResources === 'function'
          ? moduleResources
          : moduleResources.reducer;
        // User higher-order reducer (which handles HYDRATE and CLEAR_STATE actions
        reducers[moduleName] = moduleReducer(moduleName, reducer);
      });

      reduxStore = createReduxStore(
        combineReducers(reducers),
        preloadedState
      );

      state$ = Observable.from(reduxStore)
        .publishReplay(1)
        .refCount();
    }

    /**
     * Dispacthes the given action
     */
    function dispatch(action) {
      reduxStore.dispatch(action);
      dispatch$.next(action);
    }

    /**
     * Gets the state stream for given module
     */
    function getState$(moduleName) {
      let stateStream = stateStreams[moduleName];
      if (stateStream) {
        return stateStream;
      }

      const def = definitions[moduleName];
      if (def.effects) {
        // The API provided to each effects function in addition to the dispatch$
        const fxAPI = {
          getState: reduxStore.getState,
          getState$,
          effects$: sideEffect$.filter(a => a.meta !== moduleName).delay(0, Scheduler.asap),
          dispatch,
        };

        const effectsStreams = def.effects(dispatch$, fxAPI);
        stateStream = createState$(
          moduleName,
          effectsStreams
        );
      } else {
        stateStream = state$.pluck(moduleName)
          .distinctUntilChanged()
          .publishReplay(1)
          .refCount();
      }

      stateStreams[moduleName] = stateStream;
      return stateStream;
    }

    /**
     * Create a module's state stream with provided effects streams
     */
    function createState$(moduleName, effectsStreams) {
      const effects$ = Observable.merge(...effectsStreams);
      let effectsSubscription;
      return state$
        .pluck(moduleName)
        .startWith(CONNECT_STREAM)
        .do(v => {
          if (v !== CONNECT_STREAM) {
            return;
          }
          effectsSubscription = effects$.subscribe(action => {
            reduxStore.dispatch(action);
            sideEffect$.next({
              ...action,
              meta: moduleName,
            });
          });
        })
        .skip(1)
        .finally(() => effectsSubscription.unsubscribe())
        .distinctUntilChanged()
        .publishReplay(1)
        .refCount();
    }

    /**
     * Hydrates the state of the given module by dispatching a HYDRATE action.
     * This action is automatically handled by the module's higher-order reducer
     */
    function hydrate(moduleName, h) {
      reduxStore.dispatch({
        type: hydrateActionType(moduleName),
        payload: h,
      });
    }

    /**
     * Clears the state of the given module (setting it back to the initial state) by
     * dispatching a CLEAR_STATE action. This action is automatically handled by
     * the module's higher-order reducer
     */
    function clearState(moduleName) {
      reduxStore.dispatch({
        type: clearStateActionType(moduleName)
      });
    }

    // Init
    init(definitions);

    // Store API
    return {
      ...reduxStore,
      dispatch,
      getState$,
      hydrate,
      clearState,
    };
  };
}
