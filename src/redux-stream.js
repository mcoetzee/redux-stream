import { Observable, Subject } from './rx-ext';
import { combineReducers } from 'redux';
import { moduleReducer, hydrateActionType, clearStateActionType } from './module-utils';

export default function reduxStream(createReduxStore) {
  /**
   * @typedef moduleDefinition
   * @type {Object}
   * @property {Function} [effects] - Provides the module's side effects.
   * Returns an array of side effect producers.
   * @property {Function} reducer - Plain old reducer function.
   */

  /**
   * Creates a Redux Store which adds RxJS effects streams into the data flow and allows subscription
   * to state streams by module.
   *
   * @param {Object} definitions - The module definitions. Each module definition
   * provides optional side effect producers and a reducer.
   *
   * @param {Object} [preloadedState] - The initial state. Can be used to hydrate
   * the store from state generated by the server in universal apps.
   *
   * @returns {Object} store - A Redux Stream store that allows you to subscribe to the state streams,
   * dispatch actions and read the current state of the application.
   */
  return function createStore(definitions, preloadedState) {
    // The stream where actions are dispatched into
    const action$ = new Subject();
    // Collection of state streams by module
    const stateStreams = {};
    let reduxStore;
    // The state stream of the entire app
    let state$;

    /**
     * Initialize the store with provided module definitions
     */
    function init(defs) {
      const reducers = {};
      const sideEffectStreams = [];
      // Tools to compose side effects (in addtion to the action stream)
      const effectsAPI = { getState: () => reduxStore.getState(), getState$, dispatch };

      Object.keys(defs).forEach(moduleName => {
        let reducer;
        const moduleResources = defs[moduleName];
        if (typeof moduleResources === 'function') {
          reducer = moduleResources;
        } else {
          reducer = moduleResources.reducer;
          if (moduleResources.effects) {
            sideEffectStreams.push(...moduleResources.effects.map(e => e(action$, effectsAPI)));
          }
        }
        // User higher-order reducer (which handles HYDRATE and CLEAR_STATE actions)
        reducers[moduleName] = moduleReducer(moduleName, reducer);
      });

      reduxStore = createReduxStore(
        combineReducers(reducers),
        preloadedState
      );

      // Create the state stream from the Redux store. It just works (TM)
      state$ = Observable.from(reduxStore)
        .publishReplay(1)
        .refCount();

      if (sideEffectStreams.length) {
        Observable.merge(...sideEffectStreams).subscribe(action => {
          reduxStore.dispatch(action);
          action$.next(action);
        });
      }
    }

    /**
     * Dispacthes the given action. Allows minimal thunks to be dispatched to cater
     * for conditional dispatching etc.
     */
    function dispatch(action) {
      if (typeof action === 'function') {
        action(dispatch, reduxStore.getState);
        return;
      }
      reduxStore.dispatch(action);
      action$.next(action);
    }

    /**
     * Gets the state stream for given module or creates it if not yet added.
     */
    function getState$(moduleName) {
      let stateStream = stateStreams[moduleName];
      if (stateStream) {
        return stateStream;
      }

      if (!state$) {
        return Observable.defer(() => pluckAndCacheState$(moduleName));
      }

      return pluckAndCacheState$(moduleName);
    }

    function pluckAndCacheState$(moduleName) {
      const stateStream = state$.pluck(moduleName)
        .distinctUntilChanged()
        .publishReplay(1)
        .refCount();

      stateStreams[moduleName] = stateStream;
      return stateStream;
    }

    /**
     * Hydrates the state of the given module by dispatching a HYDRATE action.
     * This action is automatically handled by the module's higher-order reducer
     */
    function hydrate(moduleName, h) {
      reduxStore.dispatch({
        type: hydrateActionType(moduleName),
        payload: h,
      });
    }

    /**
     * Clears the state of the given module (setting it back to the initial state) by
     * dispatching a CLEAR_STATE action. This action is automatically handled by
     * the module's higher-order reducer
     */
    function clearState(moduleName) {
      reduxStore.dispatch({
        type: clearStateActionType(moduleName)
      });
    }

    // Init
    init(definitions);

    // Store API
    return {
      ...reduxStore,
      dispatch,
      getState$,
      hydrate,
      clearState,
    };
  };
}
