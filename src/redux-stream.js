import { Observable, Subject } from './rx-ext';
import { Scheduler } from 'rxjs';
import { combineReducers } from 'redux';
import { moduleReducer, hydrateActionType, clearStateActionType } from './module-utils';

const CONNECT_STREAM = '@udeo/CONNECT_STREAM';

export function reduxStream(createReduxStore) {
  /**
   * @typedef moduleDefinition
   * @type {Object}
   * @property {Function} [effects] - Provides the module's side effects.
   * Returns an array of action streams to be reduced.
   * @property {Function} reducer - The reducer of the provided data flow.
   * Returns the next version of the module's state (a plain old reducer function).
   */

  /**
   * Creates a Redux Store which houses a collection of state streams. It lazily adds a state
   * stream for each module definition provided.
   *
   * @param {Object} definitions - The module definitions. Each module definition
   * provides two functions used to form the module's state stream.
   *
   * @param {Object} [preloadedState] - The initial state. Can be used to hydrate
   * the store from state generated by the server in universal apps.
   *
   * @returns {Object} store - A Redux Stream store that allows you to subscribe to the state streams,
   * dispatch actions and read the current state of the application.
   */
  return function createStore(definitions, preloadedState) {
    // The stream where actions are dispatched into
    const dispatch$ = new Subject();
    // The stream where all modules' effects flow through
    const sideEffect$ = new Subject();
    // Collection of state streams by module - each one is lazily added
    const stateStreams = {};
    let reduxStore;
    // The state stream of the entire app
    let state$;

    /**
     * Initialize the store with provided module definitions
     */
    function init(defs) {
      const moduleNames = Object.keys(defs);
      const reducers = {};
      let reducer;
      moduleNames.forEach(moduleName => {
        const moduleResources = defs[moduleName];
        reducer = typeof moduleResources === 'function'
          ? moduleResources
          : moduleResources.reducer;
        // User higher-order reducer (which handles HYDRATE and CLEAR_STATE actions)
        reducers[moduleName] = moduleReducer(moduleName, reducer);
      });

      reduxStore = createReduxStore(
        combineReducers(reducers),
        preloadedState
      );

      // Create the state stream from the Redux store. It just works (TM)
      state$ = Observable.from(reduxStore)
        .publishReplay(1)
        .refCount();
    }

    /**
     * Dispacthes the given action
     */
    function dispatch(action) {
      reduxStore.dispatch(action);
      dispatch$.next(action);
    }

    /**
     * Gets the state stream for given module or creates it if not yet added.
     */
    function getState$(moduleName) {
      let stateStream = stateStreams[moduleName];
      if (stateStream) {
        return stateStream;
      }

      const moduleDefinition = definitions[moduleName];
      if (moduleDefinition.effects) {
        // All side effects flow though the sideEffect$, so we filter out the effect
        // streams that originate from this module to avoid unnecessary round-abouts
        const effects$ = sideEffect$
          .filter(a => a.meta !== moduleName)
          .delay(0, Scheduler.asap);

        // The main source for forming side effects - the action stream
        const action$ = dispatch$.merge(effects$);

        // API provided to form effects streams over and above the main source
        const fxAPI = {
          getState: reduxStore.getState,
          // Can be used to compose side-effects of independent modules
          getState$,
          // An escape hatch if stream composition doesn't fit
          dispatch,
        };

        const effectsStreams = moduleDefinition.effects(action$, fxAPI);

        stateStream = createState$(moduleName, effectsStreams);
      } else {
        stateStream = state$.pluck(moduleName)
          .distinctUntilChanged()
          .publishReplay(1)
          .refCount();
      }

      stateStreams[moduleName] = stateStream;
      return stateStream;
    }

    /**
     * Create a module's state stream with provided effects streams
     */
    function createState$(moduleName, effectsStreams) {
      const effects$ = Observable.merge(...effectsStreams);
      let effectsSubscription;
      return state$
        .pluck(moduleName)
        // Start with the instruction to connect the module's effects stream.
        // This only fires on subscribe or re-subscribe after going cold
        .startWith(CONNECT_STREAM)
        .do(v => {
          if (v !== CONNECT_STREAM) {
            return;
          }
          // Subscribe to the module's effects stream so that we can dispatch
          // the side effects to the reducers
          effectsSubscription = effects$.subscribe(action => {
            reduxStore.dispatch(action);
            // Other modules might be interested in this effect so pass it along
            sideEffect$.next({
              ...action,
              meta: moduleName,
            });
          });
        })
        // Skip the connect instruction
        .skip(1)
        // Clean up after the last observer unsubscribes
        .finally(() => effectsSubscription.unsubscribe())
        // Only let new state though
        .distinctUntilChanged()
        .publishReplay(1)
        .refCount();
    }

    /**
     * Hydrates the state of the given module by dispatching a HYDRATE action.
     * This action is automatically handled by the module's higher-order reducer
     */
    function hydrate(moduleName, h) {
      reduxStore.dispatch({
        type: hydrateActionType(moduleName),
        payload: h,
      });
    }

    /**
     * Clears the state of the given module (setting it back to the initial state) by
     * dispatching a CLEAR_STATE action. This action is automatically handled by
     * the module's higher-order reducer
     */
    function clearState(moduleName) {
      reduxStore.dispatch({
        type: clearStateActionType(moduleName)
      });
    }

    // Init
    init(definitions);

    // Store API
    return {
      ...reduxStore,
      dispatch,
      getState$,
      hydrate,
      clearState,
    };
  };
}
